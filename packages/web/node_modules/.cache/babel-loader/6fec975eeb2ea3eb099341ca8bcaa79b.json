{"ast":null,"code":"var Class = require('../../core/class');\n\nvar Transform = require('../../core/transform');\n\nvar Color = require('../../core/color');\n\nvar Node = require('./node');\n\nvar DOM = require('./dom');\n\nvar precision = 100;\nvar defaultBox = {\n  left: 0,\n  top: 0,\n  width: 500,\n  height: 500\n};\nmodule.exports = Class(Node, {\n  element_initialize: Node.prototype.initialize,\n  initialize: function (tag) {\n    this.element_initialize(tag);\n    var element = this.element;\n    var skew = this.skewElement = DOM.createElement('skew');\n    skew.on = true;\n    element.appendChild(skew);\n    var fill = this.fillElement = DOM.createElement('fill');\n    fill.on = false;\n    element.appendChild(fill);\n    var stroke = this.strokeElement = DOM.createElement('stroke');\n    stroke.on = false;\n    element.appendChild(stroke);\n  },\n\n  /* transform */\n  _transform: function () {\n    var container = this.parentNode; // Active Transformation Matrix\n\n    var m = container ? new Transform(container._activeTransform).transform(this) : this; // Box in shape user space\n\n    var box = this._boxCoords || this._size || defaultBox;\n    var originX = box.left || 0,\n        originY = box.top || 0,\n        width = box.width || 1,\n        height = box.height || 1; // Flipped\n\n    var flip = m.yx / m.xx > m.yy / m.xy;\n    if (m.xx < 0 ? m.xy >= 0 : m.xy < 0) flip = !flip;\n    flip = flip ? -1 : 1;\n    m = new Transform().scale(flip, 1).transform(m); // Rotation is approximated based on the transform\n\n    var rotation = Math.atan2(-m.xy, m.yy) * 180 / Math.PI; // Reverse the rotation, leaving the final transform in box space\n\n    var rad = rotation * Math.PI / 180,\n        sin = Math.sin(rad),\n        cos = Math.cos(rad);\n    var transform = new Transform(m.xx * cos - m.xy * sin, (m.yx * cos - m.yy * sin) * flip, (m.xy * cos + m.xx * sin) * flip, m.yy * cos + m.yx * sin);\n    var rotationTransform = new Transform().rotate(rotation, 0, 0);\n    var shapeToBox = new Transform().rotate(-rotation, 0, 0).transform(m).moveTo(0, 0); // Scale box after reversing rotation\n\n    width *= Math.abs(shapeToBox.xx);\n    height *= Math.abs(shapeToBox.yy); // Place box\n\n    var left = m.x,\n        top = m.y; // Compensate for offset by center origin rotation\n\n    var vx = -width / 2,\n        vy = -height / 2;\n    var point = rotationTransform.point(vx, vy);\n    left -= point.x - vx;\n    top -= point.y - vy; // Adjust box position based on offset\n\n    var rsm = new Transform(m).moveTo(0, 0);\n    point = rsm.point(originX, originY);\n    left += point.x;\n    top += point.y;\n    if (flip < 0) left = -left - width; // Place transformation origin\n\n    var point0 = rsm.point(-originX, -originY);\n    var point1 = rotationTransform.point(width, height);\n    var point2 = rotationTransform.point(width, 0);\n    var point3 = rotationTransform.point(0, height);\n    var minX = Math.min(0, point1.x, point2.x, point3.x),\n        maxX = Math.max(0, point1.x, point2.x, point3.x),\n        minY = Math.min(0, point1.y, point2.y, point3.y),\n        maxY = Math.max(0, point1.y, point2.y, point3.y);\n    var transformOriginX = (point0.x - point1.x / 2) / (maxX - minX) * flip,\n        transformOriginY = (point0.y - point1.y / 2) / (maxY - minY); // Adjust the origin\n\n    point = shapeToBox.point(originX, originY);\n    originX = point.x;\n    originY = point.y; // Scale stroke\n\n    var strokeWidth = this._strokeWidth;\n\n    if (strokeWidth) {\n      // Scale is the hypothenus between the two vectors\n      // TODO: Use area calculation instead\n      var vx = m.xx + m.xy,\n          vy = m.yy + m.yx;\n      strokeWidth *= Math.sqrt(vx * vx + vy * vy) / Math.sqrt(2);\n    } // convert to multiplied precision space\n\n\n    originX *= precision;\n    originY *= precision;\n    left *= precision;\n    top *= precision;\n    width *= precision;\n    height *= precision; // Set box\n\n    var element = this.element;\n    element.coordorigin = originX + ',' + originY;\n    element.coordsize = width + ',' + height;\n    element.style.left = left + 'px';\n    element.style.top = top + 'px';\n    element.style.width = width;\n    element.style.height = height;\n    element.style.rotation = rotation.toFixed(8);\n    element.style.flip = flip < 0 ? 'x' : ''; // Set transform\n\n    var skew = this.skewElement;\n    skew.matrix = [transform.xx.toFixed(4), transform.xy.toFixed(4), transform.yx.toFixed(4), transform.yy.toFixed(4), 0, 0];\n    skew.origin = transformOriginX + ',' + transformOriginY; // Set stroke\n\n    this.strokeElement.weight = strokeWidth + 'px';\n  },\n\n  /* styles */\n  _createGradient: function (style, stops) {\n    var fill = this.fillElement; // Temporarily eject the fill from the DOM\n\n    this.element.removeChild(fill);\n    fill.type = style;\n    fill.method = 'none';\n    fill.rotate = true;\n    var colors = [],\n        color1,\n        color2;\n\n    var addColor = function (offset, color) {\n      color = Color.detach(color);\n      if (color1 == null) color1 = color2 = color;else color2 = color;\n      colors.push(offset + ' ' + color[0]);\n    }; // Enumerate stops, assumes offsets are enumerated in order\n\n\n    if ('length' in stops) for (var i = 0, l = stops.length - 1; i <= l; i++) addColor(i / l, stops[i]);else for (var offset in stops) addColor(offset, stops[offset]);\n    fill.color = color1[0];\n    fill.color2 = color2[0]; //if (fill.colors) fill.colors.value = colors; else\n\n    fill.colors = colors; // Opacity order gets flipped when color stops are specified\n\n    fill.opacity = color2[1];\n    fill['ao:opacity2'] = color1[1];\n    fill.on = true;\n    this.element.appendChild(fill);\n    return fill;\n  },\n  _setColor: function (type, color) {\n    var element = type == 'fill' ? this.fillElement : this.strokeElement;\n\n    if (color == null) {\n      element.on = false;\n    } else {\n      color = Color.detach(color);\n      element.color = color[0];\n      element.opacity = color[1];\n      element.on = true;\n    }\n  },\n  fill: function (color) {\n    if (arguments.length > 1) {\n      this.fillLinear(arguments);\n    } else {\n      this._boxCoords = defaultBox;\n      var fill = this.fillElement;\n      fill.type = 'solid';\n      fill.color2 = '';\n      fill['ao:opacity2'] = '';\n      if (fill.colors) fill.colors.value = '';\n\n      this._setColor('fill', color);\n    }\n\n    return this;\n  },\n  fillRadial: function (stops, focusX, focusY, radiusX, radiusY, centerX, centerY) {\n    var fill = this._createGradient('gradientradial', stops);\n\n    if (focusX == null) focusX = this.left + this.width * 0.5;\n    if (focusY == null) focusY = this.top + this.height * 0.5;\n    if (radiusY == null) radiusY = radiusX || this.height * 0.5;\n    if (radiusX == null) radiusX = this.width * 0.5;\n    if (centerX == null) centerX = focusX;\n    if (centerY == null) centerY = focusY;\n    centerX += centerX - focusX;\n    centerY += centerY - focusY;\n    var box = this._boxCoords = {\n      left: centerX - radiusX * 2,\n      top: centerY - radiusY * 2,\n      width: radiusX * 4,\n      height: radiusY * 4\n    };\n    focusX -= box.left;\n    focusY -= box.top;\n    focusX /= box.width;\n    focusY /= box.height;\n    fill.focussize = '0 0';\n    fill.focusposition = focusX + ',' + focusY;\n    fill.focus = '50%';\n\n    this._transform();\n\n    return this;\n  },\n  fillLinear: function (stops, x1, y1, x2, y2) {\n    var fill = this._createGradient('gradient', stops);\n\n    fill.focus = '100%';\n\n    if (arguments.length == 5) {\n      var w = Math.abs(x2 - x1),\n          h = Math.abs(y2 - y1);\n      this._boxCoords = {\n        left: Math.min(x1, x2),\n        top: Math.min(y1, y2),\n        width: w < 1 ? h : w,\n        height: h < 1 ? w : h\n      };\n      fill.angle = (360 + Math.atan2((x2 - x1) / h, (y2 - y1) / w) * 180 / Math.PI) % 360;\n    } else {\n      this._boxCoords = null;\n      fill.angle = x1 == null ? 0 : (90 + x1) % 360;\n    }\n\n    this._transform();\n\n    return this;\n  },\n  fillImage: function (url, width, height, left, top, color1, color2) {\n    var fill = this.fillElement;\n\n    if (color1 != null) {\n      color1 = Color.detach(color1);\n      if (color2 != null) color2 = Color.detach(color2);\n      fill.type = 'pattern';\n      fill.color = color1[0];\n      fill.color2 = color2 == null ? color1[0] : color2[0];\n      fill.opacity = color2 == null ? 0 : color2[1];\n      fill['ao:opacity2'] = color1[1];\n    } else {\n      fill.type = 'tile';\n      fill.color = '';\n      fill.color2 = '';\n      fill.opacity = 1;\n      fill['ao:opacity2'] = 1;\n    }\n\n    if (fill.colors) fill.colors.value = '';\n    fill.rotate = true;\n    fill.src = url;\n    fill.size = '1,1';\n    fill.position = '0,0';\n    fill.origin = '0,0';\n    fill.aspect = 'ignore'; // ignore, atleast, atmost\n\n    fill.on = true;\n    if (!left) left = 0;\n    if (!top) top = 0;\n    this._boxCoords = width ? {\n      left: left + 0.5,\n      top: top + 0.5,\n      width: width,\n      height: height\n    } : null;\n\n    this._transform();\n\n    return this;\n  },\n\n  /* stroke */\n  stroke: function (color, width, cap, join) {\n    var stroke = this.strokeElement;\n    this._strokeWidth = width != null ? width : 1;\n    stroke.weight = width != null ? width + 'px' : 1;\n    stroke.endcap = cap != null ? cap == 'butt' ? 'flat' : cap : 'round';\n    stroke.joinstyle = join != null ? join : 'round';\n\n    this._setColor('stroke', color);\n\n    return this;\n  }\n});","map":{"version":3,"sources":["/Users/quickmac/Desktop/node_projects/react-native-web-workout/node_modules/art/modes/vml/base.js"],"names":["Class","require","Transform","Color","Node","DOM","precision","defaultBox","left","top","width","height","module","exports","element_initialize","prototype","initialize","tag","element","skew","skewElement","createElement","on","appendChild","fill","fillElement","stroke","strokeElement","_transform","container","parentNode","m","_activeTransform","transform","box","_boxCoords","_size","originX","originY","flip","yx","xx","yy","xy","scale","rotation","Math","atan2","PI","rad","sin","cos","rotationTransform","rotate","shapeToBox","moveTo","abs","x","y","vx","vy","point","rsm","point0","point1","point2","point3","minX","min","maxX","max","minY","maxY","transformOriginX","transformOriginY","strokeWidth","_strokeWidth","sqrt","coordorigin","coordsize","style","toFixed","matrix","origin","weight","_createGradient","stops","removeChild","type","method","colors","color1","color2","addColor","offset","color","detach","push","i","l","length","opacity","_setColor","arguments","fillLinear","value","fillRadial","focusX","focusY","radiusX","radiusY","centerX","centerY","focussize","focusposition","focus","x1","y1","x2","y2","w","h","angle","fillImage","url","src","size","position","aspect","cap","join","endcap","joinstyle"],"mappings":"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","sourcesContent":["var Class = require('../../core/class');\nvar Transform = require('../../core/transform');\nvar Color = require('../../core/color');\nvar Node = require('./node');\nvar DOM = require('./dom');\n\nvar precision = 100;\n\nvar defaultBox = { left: 0, top: 0, width: 500, height: 500 };\n\nmodule.exports = Class(Node, {\n\n\telement_initialize: Node.prototype.initialize,\n\n\tinitialize: function(tag){\n\t\tthis.element_initialize(tag);\n\t\tvar element = this.element;\n\t\t\n\t\tvar skew = this.skewElement = DOM.createElement('skew');\n\t\tskew.on = true;\n\t\telement.appendChild(skew);\n\n\t\tvar fill = this.fillElement = DOM.createElement('fill');\n\t\tfill.on = false;\n\t\telement.appendChild(fill);\n\t\t\n\t\tvar stroke = this.strokeElement = DOM.createElement('stroke');\n\t\tstroke.on = false;\n\t\telement.appendChild(stroke);\n\t},\n\t\n\t/* transform */\n\t\n\t_transform: function(){\n\t\tvar container = this.parentNode;\n\t\t\n\t\t// Active Transformation Matrix\n\t\tvar m = container ? new Transform(container._activeTransform).transform(this) : this;\n\t\t\n\t\t// Box in shape user space\n\t\t\n\t\tvar box = this._boxCoords || this._size || defaultBox;\n\t\t\n\t\tvar originX = box.left || 0,\n\t\t\toriginY = box.top || 0,\n\t\t\twidth = box.width || 1,\n\t\t\theight = box.height || 1;\n\t\t\t\t\n\t\t// Flipped\n\t    var flip = m.yx / m.xx > m.yy / m.xy;\n\t\tif (m.xx < 0 ? m.xy >= 0 : m.xy < 0) flip = !flip;\n\t\tflip = flip ? -1 : 1;\n\t\t\n\t\tm = new Transform().scale(flip, 1).transform(m);\n\t\t\n\t\t// Rotation is approximated based on the transform\n\t\tvar rotation = Math.atan2(-m.xy, m.yy) * 180 / Math.PI;\n\t\t\n\t\t// Reverse the rotation, leaving the final transform in box space\n\t\tvar rad = rotation * Math.PI / 180, sin = Math.sin(rad), cos = Math.cos(rad);\n\t\t\n\t\tvar transform = new Transform(\n\t\t\t(m.xx * cos - m.xy * sin),\n\t\t\t(m.yx * cos - m.yy * sin) * flip,\n\t\t\t(m.xy * cos + m.xx * sin) * flip,\n\t\t\t(m.yy * cos + m.yx * sin)\n\t\t);\n\n\t\tvar rotationTransform = new Transform().rotate(rotation, 0, 0);\n\n\t\tvar shapeToBox = new Transform().rotate(-rotation, 0, 0).transform(m).moveTo(0,0);\n\n\t\t// Scale box after reversing rotation\n\t\twidth *= Math.abs(shapeToBox.xx);\n\t\theight *= Math.abs(shapeToBox.yy);\n\t\t\n\t\t// Place box\n\t\tvar left = m.x, top = m.y;\n\t\t\n\t\t// Compensate for offset by center origin rotation\n\t\tvar vx = -width / 2, vy = -height / 2;\n\t\tvar point = rotationTransform.point(vx, vy);\n\t\tleft -= point.x - vx;\n\t\ttop -= point.y - vy;\n\t\t\n\t\t// Adjust box position based on offset\n\t\tvar rsm = new Transform(m).moveTo(0,0);\n\t\tpoint = rsm.point(originX, originY);\n\t\tleft += point.x;\n\t\ttop += point.y;\n\t\t\n\t\tif (flip < 0) left = -left - width;\n\t\t\n\t\t// Place transformation origin\n\t\tvar point0 = rsm.point(-originX, -originY);\n\t\tvar point1 = rotationTransform.point(width, height);\n\t\tvar point2 = rotationTransform.point(width, 0);\n\t\tvar point3 = rotationTransform.point(0, height);\n\t\t\n\t\tvar minX = Math.min(0, point1.x, point2.x, point3.x),\n\t\t    maxX = Math.max(0, point1.x, point2.x, point3.x),\n\t\t    minY = Math.min(0, point1.y, point2.y, point3.y),\n\t\t    maxY = Math.max(0, point1.y, point2.y, point3.y);\n\t\t\n\t\tvar transformOriginX = (point0.x - point1.x / 2) / (maxX - minX) * flip,\n\t\t    transformOriginY = (point0.y - point1.y / 2) / (maxY - minY);\n\t\t\n\t\t// Adjust the origin\n\t\tpoint = shapeToBox.point(originX, originY);\n\t\toriginX = point.x;\n\t\toriginY = point.y;\n\t\t\n\t\t// Scale stroke\n\t\tvar strokeWidth = this._strokeWidth;\n\t\tif (strokeWidth){\n\t\t\t// Scale is the hypothenus between the two vectors\n\t\t\t// TODO: Use area calculation instead\n\t\t\tvar vx = m.xx + m.xy, vy = m.yy + m.yx;\n\t\t\tstrokeWidth *= Math.sqrt(vx * vx + vy * vy) / Math.sqrt(2);\n\t\t}\n\t\t\n\t\t// convert to multiplied precision space\n\t\toriginX *= precision;\n\t\toriginY *= precision;\n\t\tleft *= precision;\n\t\ttop *= precision;\n\t\twidth *= precision;\n\t\theight *= precision;\n\t\t\n\t\t// Set box\n\t\tvar element = this.element;\n\t\telement.coordorigin = originX + ',' + originY;\n\t\telement.coordsize = width + ',' + height;\n\t\telement.style.left = left + 'px';\n\t\telement.style.top = top + 'px';\n\t\telement.style.width = width;\n\t\telement.style.height = height;\n\t\telement.style.rotation = rotation.toFixed(8);\n\t\telement.style.flip = flip < 0 ? 'x' : '';\n\t\t\n\t\t// Set transform\n\t\tvar skew = this.skewElement;\n\t\tskew.matrix = [transform.xx.toFixed(4), transform.xy.toFixed(4), transform.yx.toFixed(4), transform.yy.toFixed(4), 0, 0];\n\t\tskew.origin = transformOriginX + ',' + transformOriginY;\n\n\t\t// Set stroke\n\t\tthis.strokeElement.weight = strokeWidth + 'px';\n\t},\n\t\n\t/* styles */\n\n\t_createGradient: function(style, stops){\n\t\tvar fill = this.fillElement;\n\n\t\t// Temporarily eject the fill from the DOM\n\t\tthis.element.removeChild(fill);\n\n\t\tfill.type = style;\n\t\tfill.method = 'none';\n\t\tfill.rotate = true;\n\n\t\tvar colors = [], color1, color2;\n\n\t\tvar addColor = function(offset, color){\n\t\t\tcolor = Color.detach(color);\n\t\t\tif (color1 == null) color1 = color2 = color;\n\t\t\telse color2 = color;\n\t\t\tcolors.push(offset + ' ' + color[0]);\n\t\t};\n\n\t\t// Enumerate stops, assumes offsets are enumerated in order\n\t\tif ('length' in stops) for (var i = 0, l = stops.length - 1; i <= l; i++) addColor(i / l, stops[i]);\n\t\telse for (var offset in stops) addColor(offset, stops[offset]);\n\t\t\n\t\tfill.color = color1[0];\n\t\tfill.color2 = color2[0];\n\t\t\n\t\t//if (fill.colors) fill.colors.value = colors; else\n\t\tfill.colors = colors;\n\n\t\t// Opacity order gets flipped when color stops are specified\n\t\tfill.opacity = color2[1];\n\t\tfill['ao:opacity2'] = color1[1];\n\n\t\tfill.on = true;\n\t\tthis.element.appendChild(fill);\n\t\treturn fill;\n\t},\n\t\n\t_setColor: function(type, color){\n\t\tvar element = type == 'fill' ? this.fillElement : this.strokeElement;\n\t\tif (color == null){\n\t\t\telement.on = false;\n\t\t} else {\n\t\t\tcolor = Color.detach(color);\n\t\t\telement.color = color[0];\n\t\t\telement.opacity = color[1];\n\t\t\telement.on = true;\n\t\t}\n\t},\n\t\n\tfill: function(color){\n\t\tif (arguments.length > 1){\n\t\t\tthis.fillLinear(arguments);\n\t\t} else {\n\t\t\tthis._boxCoords = defaultBox;\n\t\t\tvar fill = this.fillElement;\n\t\t\tfill.type = 'solid';\n\t\t\tfill.color2 = '';\n\t\t\tfill['ao:opacity2'] = '';\n\t\t\tif (fill.colors) fill.colors.value = '';\n\t\t\tthis._setColor('fill', color);\n\t\t}\n\t\treturn this;\n\t},\n\n\tfillRadial: function(stops, focusX, focusY, radiusX, radiusY, centerX, centerY){\n\t\tvar fill = this._createGradient('gradientradial', stops);\n\t\tif (focusX == null) focusX = this.left + this.width * 0.5;\n\t\tif (focusY == null) focusY = this.top + this.height * 0.5;\n\t\tif (radiusY == null) radiusY = radiusX || (this.height * 0.5);\n\t\tif (radiusX == null) radiusX = this.width * 0.5;\n\t\tif (centerX == null) centerX = focusX;\n\t\tif (centerY == null) centerY = focusY;\n\t\t\n\t\tcenterX += centerX - focusX;\n\t\tcenterY += centerY - focusY;\n\t\t\n\t\tvar box = this._boxCoords = {\n\t\t\tleft: centerX - radiusX * 2,\n\t\t\ttop: centerY - radiusY * 2,\n\t\t\twidth: radiusX * 4,\n\t\t\theight: radiusY * 4\n\t\t};\n\t\tfocusX -= box.left;\n\t\tfocusY -= box.top;\n\t\tfocusX /= box.width;\n\t\tfocusY /= box.height;\n\n\t\tfill.focussize = '0 0';\n\t\tfill.focusposition = focusX + ',' + focusY;\n\t\tfill.focus = '50%';\n\t\t\n\t\tthis._transform();\n\t\t\n\t\treturn this;\n\t},\n\n\tfillLinear: function(stops, x1, y1, x2, y2){\n\t\tvar fill = this._createGradient('gradient', stops);\n\t\tfill.focus = '100%';\n\t\tif (arguments.length == 5){\n\t\t\tvar w = Math.abs(x2 - x1), h = Math.abs(y2 - y1);\n\t\t\tthis._boxCoords = {\n\t\t\t\tleft: Math.min(x1, x2),\n\t\t\t\ttop: Math.min(y1, y2),\n\t\t\t\twidth: w < 1 ? h : w,\n\t\t\t\theight: h < 1 ? w : h\n\t\t\t};\n\t\t\tfill.angle = (360 + Math.atan2((x2 - x1) / h, (y2 - y1) / w) * 180 / Math.PI) % 360;\n\t\t} else {\n\t\t\tthis._boxCoords = null;\n\t\t\tfill.angle = (x1 == null) ? 0 : (90 + x1) % 360;\n\t\t}\n\t\tthis._transform();\n\t\treturn this;\n\t},\n\n\tfillImage: function(url, width, height, left, top, color1, color2){\n\t\tvar fill = this.fillElement;\n\t\tif (color1 != null){\n\t\t\tcolor1 = Color.detach(color1);\n\t\t\tif (color2 != null) color2 = Color.detach(color2);\n\t\t\tfill.type = 'pattern';\n\t\t\tfill.color = color1[0];\n\t\t\tfill.color2 = color2 == null ? color1[0] : color2[0];\n\t\t\tfill.opacity = color2 == null ? 0 : color2[1];\n\t\t\tfill['ao:opacity2'] = color1[1];\n\t\t} else {\n\t\t\tfill.type = 'tile';\n\t\t\tfill.color = '';\n\t\t\tfill.color2 = '';\n\t\t\tfill.opacity = 1;\n\t\t\tfill['ao:opacity2'] = 1;\n\t\t}\n\t\tif (fill.colors) fill.colors.value = '';\n\t\tfill.rotate = true;\n\t\tfill.src = url;\n\t\t\n\t\tfill.size = '1,1';\n\t\tfill.position = '0,0';\n\t\tfill.origin = '0,0';\n\t\tfill.aspect = 'ignore'; // ignore, atleast, atmost\n\t\tfill.on = true;\n\n\t\tif (!left) left = 0;\n\t\tif (!top) top = 0;\n\t\tthis._boxCoords = width ? { left: left + 0.5, top: top + 0.5, width: width, height: height } : null;\n\t\tthis._transform();\n\t\treturn this;\n\t},\n\n\t/* stroke */\n\t\n\tstroke: function(color, width, cap, join){\n\t\tvar stroke = this.strokeElement;\n\t\tthis._strokeWidth = (width != null) ? width : 1;\n\t\tstroke.weight = (width != null) ? width + 'px' : 1;\n\t\tstroke.endcap = (cap != null) ? ((cap == 'butt') ? 'flat' : cap) : 'round';\n\t\tstroke.joinstyle = (join != null) ? join : 'round';\n\n\t\tthis._setColor('stroke', color);\n\t\treturn this;\n\t}\n\n});"]},"metadata":{},"sourceType":"script"}